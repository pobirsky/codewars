### Замыкание

Вот ты вызвал функцию, в ней создаются переменные локальной области видимости, т.е. доступные только самой функции.
Под эти переменные движок JavaScript выделяет память.
Когда обычная функция завершает свое выполнение, освобождает память, которую выделял раньше, если на переменные не осталось ссылок.
В случае с замыканием, ты возвращаешь функцию обратно, т.е. ссылки остаются, поэтому движок не может освободить память, и переменные остаются доступными функции, и более никому.
Поэтому эта штука и называется замыкание, т.к. переменные замкнуты на саму функцию.
Другими словами, чтобы создать замыкание, ты должен вложить функцию в функцию, обратиться из вложенной функции к переменным оборачивающей, и вложенную функцию вернуть наружу.
До тех пор, пока возвращенная функция остается в доступе, замыкание существует.
Один из основных паттернов, для которых применяются замыкания - ограничение доступа к данным, их изоляция (ограничение их области видимости).
В то же время замыкание выступает в роли автономного атомарного хранилища данных, и, по идее, должно обеспечивать доступ к этим данным, тем или иным способом.

**Замыкание** – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
В JavaScript, все функции изначально являются замыканиями.

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства **[[Environment]]** и все они могут получить доступ к внешним переменным.


При создании функции и использовании переменных, эти переменные доступны только локально внутри функции.
На хранение этих переменных выделяется память и когда функция завершает свое выполнение, эта память очищается.
Но если внутри фунции создать вторую, то эта вложенная функция получит доступ к переменным обьявленным внешней функцией.Этот механиз и называется замыканием.
Вложенная функция замыкает на себе переменные и аргументы внешней функции, чтобы создать замыкание вложенную функцию нужно вернуть.
В JavaScript, все функции изначально являются замыканиями.
